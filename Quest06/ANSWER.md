# Quest 06. 인터넷의 이해

## Topics

- 서버와 클라이언트, 그리고 웹 브라우저
- 인터넷을 구성하는 여러 가지 프로토콜
  - IP (v4): 인터넷 프로토콜, 32비트의 주소 공간 크기를 가지며 8비트마다 .으로 구분하여 XXX.XXX.XXX.XXX 의 형태로 사용한다 (IPV4).
    - 주소를 크게 A,B,C 클래스로 나누는데, 맨 앞의 1바이트를 기준으로 A클래스(1~126), B클래스(128~191), C클래스(192~223)의 주소를 갖는다.
    - | 구분    | 구조 (s: 네트워크, h: 호스트)              | 네트워크 시작 번호 | 호스트 범위(갯수) |
      | ------- | ------------------------------------------ | ------------------ | ----------------- |
      | A클래스 | 0sss ssss. hhhh hhhh. hhhh hhhh. hhhh hhhh | 1~126              | 2^24-2            |
      | B클래스 | 10ss ssss .ssss ssss. hhhh hhhh. hhhh hhhh | 128~191            | 2^16-2            |
      | C클래스 | 110s ssss. ssss ssss. ssss ssss. hhhh hhhh | 192~223            | 2^8-2             |
    - 사용자에게 부여 가능한 주소의 경우 A클래스는 앞 1바이트를 제외한 뒤 2,3,4 바이트를, B클래스는 앞 2바이트를 제외한 뒤 3,4 바이트를, C클래스는 4번 바이트를 사용한다
  - IP (v6) : 주소 공간이 128비트의 크기를 가진다. 또한 패킷 크기에 제한이 없다 (v4 64KB)
    - 16비트의 공간을 16진수로 나타낸 8자리의 수로 표현한다 ex) 2001:0db8:85a3:08d3:1319:8a2e:0370:7334
    - 자리의 수가 0000이 되는 경우, 0으로 축약하거나 생략할 수 있다.
  - 서브넷 마스크 : 서브네팅을 하기 위한 수
    - 호스트 IP를 표시하기 위해 사용되는 수로써 연속된 1과 그 이후의 0들로 이루어져있다.
    - 1을 네트워크 영역으로, 0을 호스트 영역으로 사용하겠다는 의미
    - 네트워크 주소 : 특정 네트워크를 통칭하기 위해 사용하는 주소, 특정 네트워크의 맨 첫번째 IP 주소
    - 브로드캐스트 주소 : 특정 네트워크에 속하는 모든 호스트들이 듣게되는 주소, 특정 네트워크의 맨 마지막 주소
  - TCP
    - 패킷을 주고 받기 위한 스위칭 프로토콜, TCP 세그먼트는 헤더 섹션과, 데이터 섹션으로 구성된다.
    - 헤더의 경우 송신,수신 포트번호 / 세그먼트 누적 시퀀스 번호 (최초 0) / ACK 응답 번호 / 헤더 크기, 예비 필드, flags bit, 윈도우 크기 (한 번에 받을 수 있는 데이터의 양) / 체크섬 비트 (에러 체크용), URG 플래그 (긴급 처리 요청) 오프셋 포인터 / options (0~320 bit, 32의 배수) (/기준으로 4바이트씩 분할 표기)
    - 크게 세 가지 흐름으로 구분한다
      1. 연결 생성
         - 연결을 생성하기 위해서, 3방향 hand-shake를 수행한다 (flag-bit를 통해 각 SYN/ACK를 표시)
         - SYN : 클라이언트가 서버에 SYN 메시지를 보낸다 (시퀀스 번호는 클라이언트가 임의로 설정한 값 A)
         - SYN-ACK : 서버가 클라이언트에게 SYN-ACK 메시지로 응답한다. 이 메시지에 포함된 시퀀스 번호는 (B), 응답 번호는 (A+1)
         - ACK : 클라이언트가 서버에게 ACK 메시지를 보낸다. 이 메시지에 포함된 응답 번호는 (B+1)
      2. 자료 전송
      3. 연결 종료
         - 4방향 Hand-Shake를 사용한다
    - checksum의 경우
      1. 헤더의 일부 값들을 추출한 뒤에, 이를 16비트 단위로 나누고
      2. 각각의 합을 더한 뒤, 1의 보수를 취한다.
      3. 이 checksum을 필드에 적어서 보내고,
      4. 수신자는 같은 방식으로 계산한 뒤에 보수를 취하지 않고, 받은 체크섬과 더하여
      5. 모든 비트가 1이 나오는지 확인하면 된다.
  - HTTP
    - 주로 HTML 문서(+ 리소스)를 주고 받는데 사용하는 프로토콜, 2.0 까지는 TCP를 사용하고, 3부터는 UDP를 사용할 예정
    - 96년과 99년 각각 1.0, 1.1 표준이 제정되었고, 15년에 2.0, 21년 현재 3.0을 작업중이다.
    - 버전 1에서는 Header와 Data 부분이 Plain-text로 구성되어 있으며, 2.0에 이르러서는 이를 Header, data frame 단위로 나눈뒤, 중복 header는 보내지 않거나, 여러 stream을 통해 동시에 데이터를 주고 받는 등의 방법들을 사용하여 성능 향상을 꾀하고 있다.
- DNS

## Checklist

- 인터넷은 어떻게 동작하나요? Internet Protocol Suite의 레이어 모델에 입각하여 설명해 보세요.

  - 인터넷 프로토콜 스위트 : 컴퓨터들이 서로 정보를 주고 받는데 쓰이는 프로토콜 모음 (주로 TCP/IP)
    - 계층 구조
      - 응용 계층 : HTTP
      - 전송 계층 : TCP
      - 인터넷 계층 : IP
      - ARP : 주소 결정 프로토콜, IP 주소를 물리적 네트워크 주소로 대응시키기 위해 사용되는 프로토콜, 48비트의 네트워크 카드 주소를 뜻한다.
      - 네트워크 인터페이스 계층 : Ethernet, Wifi, ...
  - 근거리에서 서로 떨어진 두 전자기기가 유선/무선으로 서로 통신하는 프로토콜은 어떻게 동작할까요?

    - **유선** : 토큰링, 애플토크 등의 기술을 거쳐 현재는 이더넷을 흔히 사용한다

      - **Ethernet** : 다른 표준들을 대부분 대체한 네트워크 기술 규격
        - 각 기기들이 고유 MAC 주소를 갖고, 이 주소를 사용해 상호간에 데이터를 주고 받을 수 있도록 구성
        - 동작 절차는 다음과 같다
          1. 네트워크를 사용하려는 컴퓨터는 먼저 현재 네트워크 위에 흐르고 있는 데이터가 있는지를 감지한다.
          2. 만약 현재 다른 데이터가 전송 중이면 사용할 수 있을 때까지 기다리고 아니면 전송을 시작한다.
          3. 여러 군데에서 동시에 전송을 시작해 충돌이 발생하면 최소 패킷 시간 동안 전송을 계속해, 다른 컴퓨터가 충돌을 탐지할 수 있도록 한다.
          4. 그 뒤, 임의 시간 동안 기다린 뒤에 다시 신호(반송파)를 감지하고, 네트워크 사용자가 없으면 전송을 다시 시작한다.
          5. 전송을 마치면, 상위 계층에 전송이 끝났음을 알리고 끝마친다.
          6. 여러 번 다시 시도했음에도 전송에 실패하면 이를 상위 계층에 알리고 끝마친다.
      - **USB** : 직렬 포트, 병렬 포트 등 다양한 기존의 연결 방식을 대체하기 위해 만들어졌다.
        - USB 임플리멘터스 포럼에서 표준을 정하며, 인텔사가 주도하여 개발하고 있다.
        - 디바이스 연결을 감지하면, 이를 인식하고, 해당하는 드라이버를 로드하는 단계를 거친다
        - 등시성 전송 : 데이터의 전송 시간을 보증할 때 사용하는 타입
          - 데이터에 오류가 있어도 재전송을 하지 않는다 (ex. 스피커, 이어폰)
          - 토큰 패킷과 데이터 패킷으로 처리되는데, Host가 Out(토큰) 패킷을 보낸 이후 Data 패킷을 연달아 보내게 된다.
        - 이외에더 인터럽트, 벌크, 제어 전송 등이 있다.
        - 기기 클래스 개념이 존재하는데, 저장장치, 오디오 장치, I/O 장치 등에 따라서 MSC, ADC, HID 클래스로 나뉘게 된다.

    - **무선**
      - **Wifi (무선 LAN)** : 802.11 표준에 기반하여 Wifi라는 이름으로도 잘 알려져있다
        - 지원 범위가 한정적이거나, 보안성이 좋지 못하다는 단점이 있다.
        - 2.4 또는 5GHZ 주파수 영역을 사용하며, 각 주파수에는 채널이 존재하는데 20, 40, 80, 160 MHZ 너비로 구분된다.
        - 표준에 따라 ax, ac, b, g, n 등으로 나뉘며 각 표준마다 지원 주파수, 채널 너비, 최대 데이터 속도 등이 상이하다.
      - **블루투스** : 단파 전파를 사용하는 전자 장비 간의 근거리 데이터 통신 방식
        - 에릭슨의 사내 프로젝트로 개발 시작되었으며 현재는 블루투스 SIG 라는 단체에 의해 관리되고 있다.
        - 2.4GHZ 대역을 사용하여 Wifi와 간섭이 발생할 가능성이 있다.
        - 버전업이 진행되면서 보안성, 속도, 유효 거리 등의 개선이 있었다.

  - 근거리에 있는 여러 대의 전자기기가 서로 통신하는 프로토콜은 어떻게 동작할까요?
    - LAN + 허브? Wifi?
  - 아주 멀리 떨어져 있는 두 전자기기가 유선/무선으로 서로 통신하는 프로토콜은 어떻게 동작할까요?
    - WAN : LAN 규모의 통신망을 여러개 묶어서 서로 통신할 수 있도록 구성
      - 따라서 먼 거리에 있는 (다른 지역에 있는) LAN 사용자들과 데이터 통신을 할 수 있도록 해준다
      - 패킷 교환 방식을 주로 사용하는데, 네트워크 자원을 패킷 단위로 나누어 이를 전송함으로써 높은 회선 효율성과, 전송 지연 감소를 통해 통신 안정성을 확보할 수 있다.
  - 두 전자기기가 신뢰성을 가지고 통신할 수 있도록 하기 위한 프로토콜은 어떻게 동작할까요?
    - TCP, UDP, IP의 checksum을 통해 데이터를 검증
  - HTTP는 어떻게 동작할까요?
    - 요청, 응답 구조로 되어있다.
    - Stateless, 요청과 그에 따른 응답이 존재할 뿐, 다른 요청/응답과 연결되어있지 않고, 독립적으로 동작한다.
    - 구조
      - Start line : 실행되어야 할 요청 또는 수행에 대한 성공 또는 실패를 나타냅니다. 항상 한 줄 입니다.
        - 요청의 경우 HTTP 메서드(GET,POST,PUT,PATCH 등) 혹은 명사(HEAD, OPTIONS) 를 사용해 서버가 수행해야 할 동작을 나타냅니다.
        - 요청 타겟은 주로 URL, 또는 프로토콜, 포트, 도메인의 절대 경로로 나타낼 수도 있습니다.
        - 응답의 경우 프로토콜 버전, 상태코드, 상태 텍스트를 갖고 있습니다.
      - Header : 요청에 대한 설명 혹은 메시지 본문에 대한 설명이 존재합니다.
        - key : value 쌍의 형태를 갖습니다.
        - 요청 헤더 종류로는 request, entity, general 헤더가 있습니다.
        - 응답 헤더 종류로는 response, entity, general 헤더가 있습니다.
      - Blank line : 모든 메타 정보가 전송되었음을 알리는 빈 줄이 삽입됩니다.
      - Body : 요청과 관련된 내용이 옵션으로 들어가거나, 응답과 관련된 문서가 들어갑니다. 본문의 존재 유무 및 크기는 첫 줄과 HTTP 헤더에 명시됩니다.
    - 시작 줄과 헤더를 묶어서 Head 라고 부릅니다.
    - HTTP/2 에서는 위 메시지를 프레임 단위로 나누어 압축 후 사용합니다.

- 우리가 브라우저의 주소 창에 www.knowre.com 을 쳤을 때, 어떤 과정을 통해 서버의 IP 주소를 알게 될까요?
  - 사용자가 입력한 도메인 주소를 IP로 변경하는 과정이 필요.
  - 이를 담당하는 시스템이 DNS(Domain Name System)이다.
  - 구성 요소
    - 도메인 네임 스페이스 : DNS는 거대한 분산 네이밍 시스템, 네임 스페이스는 DNS가 저장/관리하는 계층적 구조를 의미한다.
      - 최상위 Root DNS 서버가 존재하고, 그 하위로 연결된 모든 노드가 연속해서 이어진 계층 구조로 되어 있다. 각 레벨의 도메인은 그 하위 도메인에 관한 정보를 관리하는 구조이다.
    - 네임 서버 : 도메인 네임 스페이스의 트리 구조에 대한 정보를 가지고 있는 서버. 리졸버로 부터 요청 받은 도메인 이름에 대한 IP 정보를 다시 리졸버로 전달해주는 역할을 수행한다.
    - 리졸버 : DNS 클라이언트의 요청을 네임 서벌 ㅗ전달하고, 네임 서버로부터 정보를 받아 클라이언트에게 제공하는 기능을 수행. 하나의 네임 서버에게 요청을 전달하고, 해당 서버에 정보가 없으면 다른 네임 서버에게 요청을 보내 정보를 받아온다.
  - 동작 과정
    1. 유저가 www.knowre.com을 브라우저 주소창에 입력
    2. 브라우저가 로컬 DNS 서버에 Query를 전송
    3. 해당 DNS 서버가 Root DNS 서버에 Query를 전송
    4. Root DNS 서버가 도메인을 관리하는 DNS 서버의 이름과 주소를 로컬 DNS 서버에 전송 (group18.sites.hubspot.net)
    5. 로컬 DNS 서버가 위 네임 서버에 Query 전송
    6. 위 네임 서버가 도메인을 관리하는 DNS 서버의 이름과 주소를 로컬 DNS 서버에 전송(group18.sites.hscoscdn10.net)
    7. 로컬 DNS 서버가 group18.sites.hscoscdn10.net 네임 서버에 Query 전송
    8. 로컬 DNS 서버가 2개의 IP 정보 수신 (199.60.103.225, 199.60.103.31)
    9. 해당 정보를 사용자의 브라우저에 전송

## Quest

- tracert(Windows가 아닌 경우 traceroute) 명령을 통해 www.google.com 까지 가는 경로를 찾아 보세요.
  - 어떤 IP주소들이 있나요?
  - 그 IP주소들은 어디에 위치해 있나요?
    - 10.180.190.1 : 서울
    - 121.138.235.85 : 서울
    - 112.189.35.153 : 서울
    - 112.189.29.105 : 서울
    - 112.189.29.141 : 서울
    - 112.189.29.97 : 서울
    - 112.174.73.178 : 서울
    - 112.174.47.230 : 서울
    - 112.174.47.162 : 서울
    - 74.125.52.16 : 미국 Oregon주
    - 72.14.194.194 : 미국 Kansas 주
    - 108.170.242.193 : 미국 Kansas 주
    - 108.170.242.161 : 미국 Kansas 주
    - 108.170.233.81 : 미국 Kansas 주
    - 172.217.25.100 : 미국 Kansas 주 - google.com
    - 매번 로딩할 때 마다 나열되는 IP 주소가 바뀐다.
- Wireshark를 통해 www.google.com 으로 요청을 날렸을 떄 어떤 TCP 패킷이 오가는지 확인해 보세요

  - TCP 패킷을 주고받는 과정은 어떻게 되나요?
  - 각각의 패킷에 어떤 정보들이 담겨 있나요?
    - 3 Way HandShake 발생
      - client -> google SYN Seq=0, WIn=65535, Len=0, port 64253 -> 80
      - google -> client SYN,ACK Seq=0, Ack=1, win=65535, Len=0 ...
      - client -> google ACK Sqe=1, Ack=1, Win=131840, Len=0 ...
    - 이후 데이터 동신 시작
      - GET / HTTP/1.1
        - HTTP 요청이 진행되어 response를 받게 된다.
      - 위 요청에 대한 응답 ACK 발생, HTTP 문서의 길이가 435 바이트 였으므로 Ack=436(직전Seq1 + 435) 으로 google -> client 전송
    - 공통적으로 목표 port, source port, seq 혹은 ack number, 상태 표현을 위한 flags, windw 크기, checksum 등을 가지고 있다.

- telnet 명령을 통해 http://www.google.com/ URL에 HTTP 요청을 날려 보세요.
  - 어떤 헤더들이 있나요?
  - 그 헤더들은 어떤 역할을 하나요? (1~4는 실패시 등장했음, 400 Bad Request)
    1. Content-Type : 리소스의 media-type을 나타내기 위해 사용됩니다. (ex. 오디오 : audio.ogg, 이미지 : image/png, HTML 문서 : text/html 등)
    2. Referrer-Policy : 생성된 요청이 Referer 헤더에서 전송된 referrer 정보에 포함되어야 하는지를 관리합니다. (referrer 헤더 : 현재 요청된 페이지의 링크 이전의 웹페이지 주소를 포함)
    3. Content-Length : 메시지 바디의 길이를 나타냅니다. (10진수)
    4. Date : 메시지가 생성된 날짜와 시간을 포함
    5. Expires : 응답이 만료되었다고 판단할 날짜/시간
    6. Cache-Control : 요청/응답 내의 캐싱 매커니즘을 정의, 요청과 응답에서 사용할 수 있는 요소가 다르다.
    7. P3P : 웹 사이트 간 프라이버시 정책을 관리하는 기준
    8. Server : 요청을 수행하는 서버의 소프트웨어 정보를 포함
    9. X-XSS-Protection : XSS 공격 필터링에 대한 옵션 설정
    10. X-Frame-Options : 브라우저가 \<frame>, \<iframe>, \<object> 에서 렌더링 할 수 있는지 여부를 나타내는데 사용, 사이트 내의 콘텐츠들이 다른 사이트에 포함되지 않도록 할 수 있다.
    11. Set-Cookie : client에게 쿠키를 전송합니다.
    12. Accept-Ranges : 서버가 범위 요청을 지원하는지를 나타내며, 지원할 경우 범위가 표현될 수 있는 단위를 나타냄
    13. Vary : 서버로부터 새로운 요청을 하는 대신, 캐시된 응답을 사용할지를 결정. 대체적으로 Cache-Control을 사용하는것이 더 명확하게 표현된다.
    14. Transfer-Encoding : 사용자에게 entity 헤더를 안전하게 전송하기 위해 사용하는 인코딩 형식을 지정합니다.

## Advanced

- HTTP의 최신 버전인 HTTP/3는 어떤 식으로 구성되어 있을까요?
  - 기존 HTTP/2 + TCP + IP 와는 다르게, TCP 대신 UDP(QUIC)를 사용한다.
  - 기존 HTTPS의 암호화 영역(Data)에 Packet Number, Ack Number, Window Size, Options들이 더해진 구조를 채택했다.
  - 모든 Hand-Shake가 단일 요청/응답으로 끝난다
  - 패킷이 개별적으로 암호화 되며, 다른 데이터 부분의 패킷을 기다릴 필요가 없다.
  - Source-Address와 무관하게, 서버-클라이언트의 연결을 고유하기 식별하는 식별자가 포함되어있어 (Connection ID), IP 주소가 변경되더라도 커넥션을 유지할 수 있다.
- TCP/IP 외에 전세계적인 네트워크를 구성하기 위한 다른 방식도 제안된 바 있을까요?
  - UDP/IP?, QUIC

## 의문점

- 네트워크 + 호스트 IP 구조로 동작하게 만든 이유는 무엇일까 그냥 주소를 통채로 고유ID값처럼 사용하는것과 다른 점이 있는가?
  - 상대적으로 작은 주소 공간을 효율적으로 이용할 수 있게 하기 위함이라고는 하는데...
- TCP/IP 통신을 하는 경우 한 번의 전송마다 IP헤더 + TCP헤더 + TCP 데이터(세그먼트) 의 구조가 되는걸까? : YES
  - TCP를 사용하는 경우 데이터(세그먼트)를 여러개로 나누어 전송하게 되는데, 이는 결국 IP 헤더에서 정하는 variable length에 따라서 어떻게 분할될지 정해진다.
- HTTP 연결 하나당 (즉, 브라우저 하나에서 페이지를 켤 때), TCP/IP 연결을 하나 생성하는것으로 보이는데, 그렇다면 크롬, 사파리, 오페라, 웨일 등 브라우저마다 naver.com을 띄운다면 TCP/IP 연결 갯수도 그만큼 늘어나게 될까?
- 근거리에 있는 여러 대의 전자기기가 서로 통신하는 프로토콜은 어떻게 동작할까요?
  - 이 질문에서 "여러 대" 라는게 잘 와닿지 않는다. 위의 방법 말고도 여러명이 동시에 상호작용 할 수 있는 프로토콜이 존재한다는 의미일까?
